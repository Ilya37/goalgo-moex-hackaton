import os
from datetime import datetime, timedelta
import pandas as pd

from langchain.agents.agent_types import AgentType
from langchain.chat_models import ChatOpenAI
from langchain_experimental.agents.agent_toolkits import create_pandas_dataframe_agent
from langchain.llms import OpenAI
import streamlit as st
from streamlit.logger import get_logger

from moexalgo import Market

logger = get_logger(__name__)

TOKEN = st.secrets["TOKEN"]


# # Page title
st.set_page_config(page_title='üõãÔ∏èüë®‚Äçüíª GPT –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ –¥–∞–Ω–Ω—ã—Ö –ú–æ—Å–∫–æ–≤—Å–∫–æ–π –±–∏—Ä–∂–∏')
st.title('üõãÔ∏èüë®‚Äçüíª GPT –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ –¥–∞–Ω–Ω—ã—Ö –ú–æ—Å–∫–æ–≤—Å–∫–æ–π –±–∏—Ä–∂–∏')

st.text("""MVP —Ä–µ—à–µ–Ω–∏—è –æ—Ç –∫–æ–º–∞–Ω–¥—ã "–î–∏–≤–∞–Ω–Ω—ã–µ —ç–∫—Å–ø–µ—Ä—Ç—ã" —Ö–∞–∫–∞—Ç–æ–Ω–∞ Go Algo –æ—Ç –ú–æ—Å–∫–æ–≤—Å–∫–æ–π –±–∏—Ä–∂–∏""")


def _generate_date_range(start_date, end_date):
    date_range = [start_date + timedelta(days=x) for x in range((end_date - start_date).days)]
    return date_range


@st.cache_data
def load_data(option, start_date, end_date):
    stocks = Market('stocks')
    dates = _generate_date_range(start_date, end_date)

    result_df = pd.DataFrame()

    if option == 'tradestats':
       for date in dates:
           response = stocks.tradestats(date=date)
           df = pd.DataFrame(response)
           result_df = pd.concat([result_df, df], ignore_index=True)
 
       with st.expander('–ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä –ø–æ–ª—É—á–µ–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –ø–æ —Å–¥–µ–ª–∫–∞–º:'):
         st.write(result_df.head(10))
       
       return result_df

    if option == 'orderstats':   
       for date in dates:
           response = stocks.orderstats(date=date)
           df = pd.DataFrame(response)
           result_df = pd.concat([result_df, df], ignore_index=True)
 
       with st.expander('–ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä –ø–æ–ª—É—á–µ–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –ø–æ –∑–∞—è–≤–∫–∞–º:'):
         st.write(result_df.head(10))
       
       return result_df
    
    if option == 'obstats':
       for date in dates:
           response = stocks.obstats(date=date)
           df = pd.DataFrame(response)
           result_df = pd.concat([result_df, df], ignore_index=True)
       
       with st.expander('–ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä –ø–æ–ª—É—á–µ–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –ø–æ —Å—Ç–∞–∫–∞–Ω–∞–º –∑–∞—è–≤–æ–∫:'):
         st.write(result_df.head(10))
   
       return result_df


# Generate LLM response
def generate_response(df, input_query):
  llm = ChatOpenAI(model_name='gpt-3.5-turbo-0613', temperature=0.2, openai_api_key=TOKEN)
  agent = create_pandas_dataframe_agent(llm, df, verbose=True, 
                                        agent_type=AgentType.OPENAI_FUNCTIONS, handle_parsing_errors=True)
  response = agent.run(input_query)
  return st.success(response, icon="‚úÖ")


# Streamlit app
def main(): 
    # Options menu with business mapping

    st.subheader('_1._ –ü—Ä–æ–≤–µ–¥–∏—Ç–µ —Ä–∞–∑–≤–µ–¥–æ—á–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –¥–∞–Ω–Ω—ã—Ö –±–∏—Ä–∂–∏ &#129299;', divider='rainbow')

    options_mapping = {
        "–°–¥–µ–ª–∫–∏": "tradestats",
        "–ó–∞—è–≤–∫–∏": "orderstats",
        "–°—Ç–∞–∫–∞–Ω –∑–∞—è–≤–æ–∫": "obstats",
    }

    # Date selection - Start Date
    start_date = st.date_input("–í—ã–±–µ—Ä–∏—Ç–µ –Ω–∞—á–∞–ª–æ –ø–µ—Ä–∏–æ–¥–∞:", datetime.today(), key="start_date")

    # Date selection - End Date
    end_date = st.date_input("–í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–Ω–µ—Ü –ø–µ—Ä–∏–æ–¥–∞:", datetime.today(), key="end_date")

    # Options selection
    selected_option = st.radio("–í—ã–±–µ—Ä–∏—Ç–µ –Ω—É–∂–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞:", options=list(options_mapping.keys()), index=None)

    question_list = [
      '–ö–∞–∫–∞—è –∞–∫—Ü–∏—è —Å–∞–º–∞—è –¥–æ—Ä–æ–≥–∞—è?',
      '–ü–æ –∫–∞–∫–æ–π –∞–∫—Ü–∏–∏ –±—ã–ª–æ –±–æ–ª—å—à–µ –≤—Å–µ–≥–æ —Å–¥–µ–ª–æ–∫?',
      '–ö–∞–∫–∞—è –±—ã–ª–∞ —Å—Ä–µ–¥–Ω—è—è —Ä–∞–∑–Ω–∏—Ü–∞ –º–µ–∂–¥—É —Ü–µ–Ω–æ–π –Ω–∞—á–∞–ª–∞ –∏ —Ü–µ–Ω–æ–π –æ–∫–æ–Ω—á–∞–Ω–∏—è —Ç–æ—Ä–≥–æ–≤?',
      '–î—Ä—É–≥–æ–µ',
    ]
    query_text = st.selectbox('–í—ã–±–µ—Ä–∏—Ç–µ –ø—Ä–∏–º–µ—Ä –≤–æ–ø—Ä–æ—Å–∞:', question_list, disabled=not selected_option)

    if query_text == '–î—Ä—É–≥–æ–µ':
      query_text = st.text_input('–í–≤–µ–¥–∏—Ç–µ –≤–∞—à –∑–∞–ø—Ä–æ—Å:', disabled=not selected_option)
    if selected_option is not None:
      st.header('–†–µ–∑—É–ª—å—Ç–∞—Ç—ã:')
      try:
        result = load_data(options_mapping[selected_option], start_date, end_date)
        generate_response(result, query_text)
      except Exception as e:
        st.error(f"""
                 –ü—Ä–æ–±–ª–µ–º—ã —Å –æ–±—Ä–∞–±–æ—Ç–∫–æ–π {selected_option}.
                 –ß—Ç–æ-—Ç–æ —Å–µ—Ä–≤–∏—Å–æ–º (–∞ —Ç–æ—á–Ω–µ–µ {str(e)}) üò≤
                 –ü–æ–≤—Ç–æ—Ä–∏—Ç–µ –ø–æ–ø—ã—Ç–∫—É –ø–æ–∑–¥–Ω–µ–µ ‚ù§Ô∏è
                 """)
        
    
    st.subheader('_2._ –ü–æ—Å—Ç—Ä–æ–π—Ç–µ —Ç–æ—Ä–≥–æ–≤—É—é —Å—Ç—Ä–∞—Ç–µ–≥–∏—é –ø–æ –∏–Ω—Ç–µ—Ä–µ—Å—É—é—â–µ–π –∞–∫—Ü–∏–∏ &#129297;', divider='rainbow')

    yesterday = (datetime.now() - timedelta(days=2)).strftime('%Y-%m-%d')
    result = load_data('tradestats', yesterday, yesterday)

    # Group by 'Ticker' and calculate the sum of 'Number_of_Trades' for each ticker
    total_trades_per_ticker = result.groupby('ticker')['trades_b'].sum()
    # Sort the tickers based on the total number of trades in descending order
    sorted_tickers = total_trades_per_ticker.sort_values(ascending=False).index.tolist()
        
    # Use an expander to create a collapsible section
    with st.expander("Options"):
        # Display options in a dropdown inside the expander
        st.caption('–í —Å–ø–∏—Å–∫–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω—ã –∞–∫—Ü–∏–∏, —Ç–æ—Ä–≥–æ–≤–∞–≤—à–∏–µ—Å—è –Ω–∞ –±–∏—Ä–∂–µ –≤—á–µ—Ä–∞, –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤—É —Ç–æ—Ä–≥–æ–≤')
        selected_option = st.selectbox('–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–∫–µ—Ä –∞–∫—Ü–∏–∏:', sorted_tickers)

    # Date selection - Start Date
    start_date_ticker = st.date_input("–í—ã–±–µ—Ä–∏—Ç–µ –Ω–∞—á–∞–ª–æ –ø–µ—Ä–∏–æ–¥–∞ –ø–æ –≤—ã–±—Ä–∞–Ω–Ω–æ–º—É —Ç–∏–∫–µ—Ä—É:", datetime.today(), key="start_date_ticker")

    # Date selection - End Date
    end_date_ticker = st.date_input("–í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–Ω–µ—Ü –ø–µ—Ä–∏–æ–¥–∞ –ø–æ –≤—ã–±—Ä–∞–Ω–Ω–æ–º—É —Ç–∏–∫–µ—Ä—É:", datetime.today(), key="end_date_ticker")

    frequency_mapping = {
        "–ú–∏–Ω—É—Ç–∞": '1m',
        "10 –º–∏–Ω—É—Ç": '10m',
        "–ß–∞—Å": '1h',
        "–î–µ–Ω—å": 'D',
        "–ù–µ–¥–µ–ª—è": 'W',
        "–ú–µ—Å—è—Ü": 'M',
        "–ö–≤–∞—Ä—Ç–∞–ª": 'Q',
    }

    selected_option = st.radio("–í—ã–±–µ—Ä–∏—Ç–µ –Ω—É–∂–Ω—É—é —á–∞—Å—Ç–æ—Ç—É —Å–±–æ—Ä–∞ –¥–∞–Ω–Ω—ã—Ö –ø–æ —Å–≤–µ—á–∞–º:", options=list(frequency_mapping.keys()), index=None)

    

    # –≤—ã–±–µ—Ä–∏—Ç–µ —Å—Ç—Ä–∞–≥–µ—Ç–∏—é
    # –ø–æ–ª—É—á–∏—Ç–µ output


if __name__ == "__main__":
    main()
